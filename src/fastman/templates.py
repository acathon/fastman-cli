"""
Code templates for project generation.
"""
from typing import Dict, Any

class Template:
    """Simple template engine with variable substitution"""

    @staticmethod
    def render(template: str, context: Dict[str, Any]) -> str:
        """Render template with context variables"""
        result = template
        for key, value in context.items():
            result = result.replace(f"{{{key}}}", str(value))
        return result


class Templates:
    """Repository of all code templates"""

    MAIN_APP = '''"""
{project_name} - FastAPI Application
Generated by Fastman v{version}
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.core.config import settings
from app.core.logging import setup_logging

# Setup logging
setup_logging()

# Initialize FastAPI
app = FastAPI(
    title=settings.PROJECT_NAME,
    version=settings.VERSION,
    docs_url="/docs" if settings.DEBUG else None,
    redoc_url="/redoc" if settings.DEBUG else None
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_HOSTS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health check
@app.get("/health")
def health_check():
    return {
        "status": "ok",
        "version": settings.VERSION,
        "environment": settings.ENVIRONMENT
    }

# Auto-discover and include routers
from app.core.discovery import discover_routers
discover_routers(app)

# GraphQL (optional)
try:
    from app.core.graphql import setup_graphql
    setup_graphql(app)
except ImportError:
    pass
'''

    CONFIG = '''"""Application configuration"""
from pydantic_settings import BaseSettings
from typing import List, Optional

class Settings(BaseSettings):
    """Application settings"""

    # Project
    PROJECT_NAME: str = "{project_name}"
    VERSION: str = "1.0.0"
    ENVIRONMENT: str = "development"
    DEBUG: bool = True

    # Security
    SECRET_KEY: str = "{secret_key}"
    ALLOWED_HOSTS: List[str] = ["*"]

    # Database (SQL)
    DATABASE_URL: Optional[str] = "sqlite:///./app.db"

    # Firebase (NoSQL)
    FIREBASE_PROJECT_ID: Optional[str] = None
    FIREBASE_CREDENTIALS_PATH: Optional[str] = None

    # API
    API_V1_PREFIX: str = "/api/v1"

    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
'''

    DATABASE = '''"""Database configuration and session management"""
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session
from typing import Generator
from app.core.config import settings

# Create engine
engine = create_engine(
    settings.DATABASE_URL,
    connect_args={"check_same_thread": False} if settings.DATABASE_URL.startswith("sqlite") else {},
    pool_pre_ping=True,
    echo=settings.DEBUG
)

# Session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for models
Base = declarative_base()

def get_db() -> Generator[Session, None, None]:
    """Dependency for database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db():
    """Initialize database tables"""
    Base.metadata.create_all(bind=engine)
'''

    DATABASE_POSTGRESQL = '''"""PostgreSQL database configuration and session management"""
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session
from typing import Generator
from app.core.config import settings

# Create engine with PostgreSQL-specific settings
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
    pool_recycle=3600,
    echo=settings.DEBUG
)

# Session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for models
Base = declarative_base()

def get_db() -> Generator[Session, None, None]:
    """Dependency for database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db():
    """Initialize database tables"""
    Base.metadata.create_all(bind=engine)
'''

    DATABASE_MYSQL = '''"""MySQL database configuration and session management"""
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session
from typing import Generator
from app.core.config import settings

# Create engine with MySQL-specific settings
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
    pool_recycle=3600,
    echo=settings.DEBUG
)

# Session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for models
Base = declarative_base()

def get_db() -> Generator[Session, None, None]:
    """Dependency for database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db():
    """Initialize database tables"""
    Base.metadata.create_all(bind=engine)
'''

    DATABASE_ORACLE = '''"""Oracle database configuration and session management"""
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session
from typing import Generator
from app.core.config import settings

# Create engine with Oracle-specific settings
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20,
    pool_recycle=3600,
    echo=settings.DEBUG
)

# Session factory
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# Base class for models
Base = declarative_base()

def get_db() -> Generator[Session, None, None]:
    """Dependency for database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db():
    """Initialize database tables"""
    Base.metadata.create_all(bind=engine)
'''

    DATABASE_FIREBASE = '''"""Firebase configuration and Firestore access"""
import firebase_admin
from firebase_admin import credentials, firestore
from typing import Optional
from app.core.config import settings
import logging

logger = logging.getLogger(__name__)

# Initialize Firebase Admin SDK
_db: Optional[firestore.Client] = None

def init_firebase():
    """Initialize Firebase Admin SDK"""
    global _db

    if _db is not None:
        return _db

    try:
        # Initialize with credentials
        cred = credentials.Certificate(settings.FIREBASE_CREDENTIALS_PATH)
        firebase_admin.initialize_app(cred, {
            'projectId': settings.FIREBASE_PROJECT_ID,
        })

        _db = firestore.client()
        logger.info("Firebase initialized successfully")
        return _db
    except Exception as e:
        logger.error(f"Failed to initialize Firebase: {e}")
        raise

def get_db() -> firestore.Client:
    """Get Firestore client instance"""
    global _db

    if _db is None:
        _db = init_firebase()

    return _db

# Collection helpers
class Collections:
    """Firestore collection names"""
    USERS = "users"
    # Add more collections as needed
'''

    LOGGING = '''"""Logging configuration"""
import logging
import sys
from pathlib import Path

def setup_logging(log_level: str = "INFO"):
    """Setup application logging"""

    # Create logs directory
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)

    # Configure logging
    logging.basicConfig(
        level=getattr(logging, log_level),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler(log_dir / "app.log")
        ]
    )

    # Set third-party loggers to WARNING
    logging.getLogger("uvicorn").setLevel(logging.WARNING)
    logging.getLogger("sqlalchemy").setLevel(logging.WARNING)
'''

    DISCOVERY = '''"""Auto-discovery of routers and features"""
import pkgutil
import importlib
from pathlib import Path
from fastapi import FastAPI, APIRouter
import logging

logger = logging.getLogger(__name__)

def discover_routers(app: FastAPI):
    """Discover and register all routers"""

    # Feature routers
    features_path = Path("app/features")
    if features_path.exists():
        for item in features_path.iterdir():
            if item.is_dir() and not item.name.startswith("_"):
                router_path = item / "router.py"
                if router_path.exists():
                    try:
                        module = importlib.import_module(f"app.features.{item.name}.router")
                        if hasattr(module, "router"):
                            app.include_router(module.router)
                            logger.info(f"Registered feature router: {item.name}")
                    except (ModuleNotFoundError, AttributeError) as e:
                        logger.error(f"Failed to load feature {item.name}: {e}")

    # API routers
    api_path = Path("app/api")
    if api_path.exists():
        for item in api_path.iterdir():
            if item.is_dir() and not item.name.startswith("_"):
                router_path = item / "router.py"
                if router_path.exists():
                    try:
                        module = importlib.import_module(f"app.api.{item.name}.router")
                        if hasattr(module, "router"):
                            app.include_router(module.router)
                            logger.info(f"Registered API router: {item.name}")
                    except (ModuleNotFoundError, AttributeError) as e:
                        logger.error(f"Failed to load API {item.name}: {e}")
'''

    GRAPHQL = '''"""GraphQL schema setup"""
import strawberry
from strawberry.fastapi import GraphQLRouter
from strawberry.tools import merge_types
from pathlib import Path
import importlib
import logging

logger = logging.getLogger(__name__)

def collect_schemas():
    """Collect all GraphQL queries and mutations"""
    queries = []
    mutations = []

    for path_name in ['features', 'api']:
        path = Path(f"app/{path_name}")
        if not path.exists():
            continue

        for item in path.iterdir():
            if not item.is_dir() or item.name.startswith("_"):
                continue

            schema_file = item / "schema.py"
            if not schema_file.exists():
                continue

            try:
                module = importlib.import_module(f"app.{path_name}.{item.name}.schema")
                if hasattr(module, "Query"):
                    queries.append(module.Query)
                if hasattr(module, "Mutation"):
                    mutations.append(module.Mutation)
            except (ModuleNotFoundError, AttributeError) as e:
                logger.error(f"Failed to load GraphQL schema from {item.name}: {e}")

    return queries, mutations

def setup_graphql(app):
    """Setup GraphQL endpoint"""
    queries, mutations = collect_schemas()

    # Default query if none found
    if not queries:
        @strawberry.type
        class Query:
            @strawberry.field
            def hello(self) -> str:
                return "Fastman GraphQL Ready"
        queries.append(Query)

    # Merge schemas
    ComboQuery = merge_types("Query", tuple(queries))
    ComboMutation = merge_types("Mutation", tuple(mutations)) if mutations else None

    schema = strawberry.Schema(
        query=ComboQuery,
        mutation=ComboMutation
    )

    graphql_app = GraphQLRouter(schema)
    app.include_router(graphql_app, prefix="/graphql")
    logger.info("GraphQL endpoint registered at /graphql")
'''

    ALEMBIC_ENV = '''"""Alembic environment configuration"""
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
import sys
from pathlib import Path

# Add project root to path
sys.path.append(str(Path(__file__).parents[2]))

from app.core.config import settings
from app.core.database import Base

# Import all models here
# This ensures they're registered with Base.metadata
from app.models import *

config = context.config
config.set_main_option("sqlalchemy.url", settings.DATABASE_URL)

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

target_metadata = Base.metadata

def run_migrations_offline():
    """Run migrations in 'offline' mode"""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    """Run migrations in 'online' mode"""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
'''

    ALEMBIC_INI = '''[alembic]
script_location = alembic
prepend_sys_path = .
version_path_separator = os

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
'''

    ALEMBIC_SCRIPT_MAKO = '''"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
'''

    GITIGNORE = '''# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
*.egg-info/
dist/
build/
*.egg

# Virtual Environment
.venv/
venv/
ENV/
env/

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# Environment
.env
.env.local
.env.*.local

# Database
*.db
*.sqlite
*.sqlite3

# Logs
logs/
*.log

# Testing
.pytest_cache/
.coverage
htmlcov/

# OS
.DS_Store
Thumbs.db

# Fastman
config_cache.json
'''
